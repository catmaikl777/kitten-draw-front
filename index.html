<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Онлайн Рисовалка для Двух Игроков</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
      /* === CSS СТИЛИ === */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary-color: #6a11cb;
        --secondary-color: #2575fc;
        --danger-color: #ff5252;
        --success-color: #4caf50;
        --warning-color: #ffc107;
        --dark-color: #2d3748;
        --light-color: #f7fafc;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          var(--secondary-color) 100%
        );
        color: white;
        min-height: 100vh;
      }

      .screen {
        display: none;
        min-height: 100vh;
        padding: 20px;
      }

      .screen.active {
        display: flex;
      }

      /* Экран входа */
      .login-container {
        max-width: 500px;
        width: 90%;
        margin: auto;
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 40px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        text-align: center;
      }

      .login-container h1 {
        font-size: 2.5rem;
        margin-bottom: 30px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .login-form input {
        width: 100%;
        padding: 15px;
        margin-bottom: 20px;
        border: none;
        border-radius: 10px;
        background-color: rgba(255, 255, 255, 0.9);
        font-size: 1rem;
        text-align: center;
      }

      .login-options {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .btn-primary,
      .btn-secondary,
      .btn-success,
      .btn-danger,
      .btn-warning {
        padding: 15px 25px;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .btn-primary {
        background-color: var(--success-color);
        color: white;
      }

      .btn-secondary {
        background-color: rgba(255, 255, 255, 0.2);
        color: white;
      }

      .btn-success {
        background-color: var(--success-color);
        color: white;
      }

      .btn-danger {
        background-color: var(--danger-color);
        color: white;
      }

      .btn-warning {
        background-color: var(--warning-color);
        color: var(--dark-color);
      }

      .btn-primary:hover,
      .btn-secondary:hover,
      .btn-success:hover,
      .btn-danger:hover,
      .btn-warning:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .divider {
        margin: 10px 0;
        font-weight: bold;
        opacity: 0.7;
      }

      .join-room {
        display: flex;
        gap: 10px;
      }

      .join-room input {
        flex: 1;
        margin-bottom: 0;
      }

      .backend-status {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        font-size: 0.9rem;
      }

      .backend-success {
        background-color: rgba(76, 175, 80, 0.2);
        color: #4caf50;
      }

      .backend-error {
        background-color: rgba(244, 67, 54, 0.2);
        color: #f44336;
      }

      /* Основной экран */
      .container {
        max-width: 1400px;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        margin: 20px auto;
      }

      .header-top {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .header-top h1 {
        font-size: 2rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .connection-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(255, 255, 255, 0.15);
        padding: 10px 20px;
        border-radius: 10px;
      }

      .players-online {
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: rgba(255, 255, 255, 0.2);
        padding: 5px 15px;
        border-radius: 20px;
      }

      /* Основной контент */
      .main-content {
        display: grid;
        grid-template-columns: 250px 1fr 300px;
        gap: 20px;
        margin: 20px 0;
      }

      @media (max-width: 1024px) {
        .main-content {
          grid-template-columns: 1fr;
          grid-template-rows: auto 1fr auto;
        }
      }

      /* Панель инструментов */
      .tools-panel {
        background-color: rgba(255, 255, 255, 0.15);
        border-radius: 15px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 25px;
      }

      .tool-section h3 {
        margin-bottom: 15px;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tool-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .tool-btn {
        padding: 10px;
        border: none;
        border-radius: 8px;
        background-color: rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        font-size: 0.8rem;
      }

      .tool-btn.active {
        background-color: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      .tool-btn:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .brush-settings {
        margin-bottom: 15px;
      }

      .brush-settings label {
        display: block;
        margin-bottom: 8px;
      }

      .brush-settings input {
        width: 100%;
        margin-bottom: 5px;
      }

      .color-palette {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
      }

      .color-option {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.3s ease;
      }

      .color-option.active {
        border-color: white;
        transform: scale(1.1);
      }

      .color-option:hover {
        transform: scale(1.1);
      }

      .action-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /* Область холста */
      .canvas-area {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .canvas-container {
        position: relative;
        background-color: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        flex: 1;
        min-height: 500px;
      }

      #drawingCanvas {
        display: block;
        background-color: white;
        cursor: crosshair;
        width: 100%;
        height: 100%;
      }

      .canvas-overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        width: 100%;
        height: 100%;
      }

      .player-indicators {
        display: flex;
        gap: 15px;
      }

      .player-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 15px;
        background-color: rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        flex: 1;
      }

      .indicator-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 1px solid white;
      }

      .player1 .indicator-color {
        background-color: #ff5252;
      }

      .player2 .indicator-color {
        background-color: #2196f3;
      }

      /* Панель чата */
      .chat-panel {
        background-color: rgba(255, 255, 255, 0.15);
        border-radius: 15px;
        display: flex;
        flex-direction: column;
        height: 500px;
      }

      .chat-header {
        padding: 15px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      }

      .chat-messages {
        flex: 1;
        padding: 15px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .chat-message {
        padding: 8px 12px;
        border-radius: 10px;
        background-color: rgba(255, 255, 255, 0.1);
        max-width: 80%;
      }

      .chat-message.own {
        background-color: rgba(76, 175, 80, 0.3);
        align-self: flex-end;
      }

      .chat-message.system {
        background-color: rgba(255, 193, 7, 0.2);
        text-align: center;
        font-style: italic;
        max-width: 100%;
      }

      .message-sender {
        font-weight: bold;
        font-size: 0.8rem;
        margin-bottom: 3px;
      }

      .message-text {
        font-size: 0.9rem;
      }

      .chat-input {
        display: flex;
        padding: 15px;
        gap: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }

      .chat-input input {
        flex: 1;
        padding: 10px 15px;
        border: none;
        border-radius: 20px;
        background-color: rgba(255, 255, 255, 0.9);
      }

      /* Информация о комнате */
      .room-info {
        margin-top: 20px;
        background-color: rgba(255, 255, 255, 0.15);
        padding: 15px 20px;
        border-radius: 10px;
      }

      .info-item {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .info-item code {
        background-color: rgba(0, 0, 0, 0.3);
        padding: 5px 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 1.1rem;
      }

      .btn-small {
        padding: 8px 12px;
        font-size: 0.8rem;
      }
    </style>
  </head>
  <body>
    <!-- Экран входа -->
    <div id="loginScreen" class="screen active">
      <div class="login-container">
        <h1><i class="fas fa-palette"></i> Онлайн Рисовалка</h1>
        <div class="login-form">
          <input
            type="text"
            id="usernameInput"
            placeholder="Введите ваше имя"
            maxlength="20"
            value="Художник"
          />
          <div class="login-options">
            <button id="createRoomBtn" class="btn-primary">
              <i class="fas fa-plus"></i> Создать комнату
            </button>
            <div class="divider">или</div>
            <div class="join-room">
              <input
                type="text"
                id="roomCodeInput"
                placeholder="Код комнаты"
                maxlength="6"
              />
              <button id="joinRoomBtn" class="btn-secondary">
                <i class="fas fa-door-open"></i> Присоединиться
              </button>
            </div>
          </div>
          <div class="backend-status">
            <span id="backendStatus">Проверка подключения...</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Основной экран -->
    <div id="mainScreen" class="screen">
      <div class="container">
        <header>
          <div class="header-top">
            <h1>
              <i class="fas fa-palette"></i> Комната:
              <span id="roomCodeDisplay"></span>
            </h1>
            <div class="header-controls">
              <button id="leaveRoomBtn" class="btn-warning">
                <i class="fas fa-sign-out-alt"></i> Покинуть комнату
              </button>
            </div>
          </div>
          <div class="connection-status">
            <span id="status">Подключение...</span>
            <div class="players-online">
              <i class="fas fa-users"></i>
              <span id="playersCount">1/2</span>
            </div>
          </div>
        </header>

        <div class="game-area">
          <div class="main-content">
            <div class="tools-panel">
              <div class="tool-section">
                <h3><i class="fas fa-paint-brush"></i> Инструменты</h3>
                <div class="tool-buttons">
                  <button class="tool-btn active" data-tool="brush">
                    <i class="fas fa-paint-brush"></i> Кисть
                  </button>
                  <button class="tool-btn" data-tool="eraser">
                    <i class="fas fa-eraser"></i> Ластик
                  </button>
                  <button class="tool-btn" data-tool="line">
                    <i class="fas fa-minus"></i> Линия
                  </button>
                  <button class="tool-btn" data-tool="rectangle">
                    <i class="fas fa-square"></i> Прямоугольник
                  </button>
                  <button class="tool-btn" data-tool="circle">
                    <i class="fas fa-circle"></i> Круг
                  </button>
                </div>
              </div>

              <div class="tool-section">
                <h3><i class="fas fa-sliders-h"></i> Настройки</h3>
                <div class="brush-settings">
                  <label>Размер кисти:</label>
                  <input
                    type="range"
                    id="brushSizeSlider"
                    min="1"
                    max="50"
                    value="5"
                  />
                  <span id="brushSizeValue">5</span>
                </div>
                <div class="color-palette">
                  <div
                    class="color-option active"
                    style="background-color: #ff5252"
                    data-color="#FF5252"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #4caf50"
                    data-color="#4CAF50"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #2196f3"
                    data-color="#2196F3"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #ffc107"
                    data-color="#FFC107"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #9c27b0"
                    data-color="#9C27B0"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #00bcd4"
                    data-color="#00BCD4"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #8bc34a"
                    data-color="#8BC34A"
                  ></div>
                  <div
                    class="color-option"
                    style="background-color: #ff9800"
                    data-color="#FF9800"
                  ></div>
                </div>
              </div>

              <div class="tool-section">
                <h3><i class="fas fa-history"></i> Действия</h3>
                <div class="action-buttons">
                  <button id="clearBtn" class="btn-danger">
                    <i class="fas fa-trash"></i> Очистить
                  </button>
                  <button id="saveBtn" class="btn-success">
                    <i class="fas fa-download"></i> Сохранить
                  </button>
                  <button id="undoBtn" class="btn-secondary">
                    <i class="fas fa-undo"></i> Отменить
                  </button>
                </div>
              </div>
            </div>

            <div class="canvas-area">
              <div class="canvas-container">
                <canvas id="drawingCanvas"></canvas>
                <canvas class="canvas-overlay" id="canvasOverlay"></canvas>
              </div>
              <div class="player-indicators">
                <div class="player-indicator player1">
                  <div class="indicator-color"></div>
                  <span id="player1Name">Игрок 1</span>
                  <i class="fas fa-crown owner-badge"></i>
                </div>
                <div class="player-indicator player2">
                  <div class="indicator-color"></div>
                  <span id="player2Name">Ожидание...</span>
                </div>
              </div>
            </div>

            <div class="chat-panel">
              <div class="chat-header">
                <h3><i class="fas fa-comments"></i> Чат</h3>
              </div>
              <div class="chat-messages" id="chatMessages">
                <div class="system-message">
                  Добро пожаловать в комнату! Ожидаем второго игрока...
                </div>
              </div>
              <div class="chat-input">
                <input
                  type="text"
                  id="chatInput"
                  placeholder="Введите сообщение..."
                  maxlength="200"
                />
                <button id="sendMessageBtn">
                  <i class="fas fa-paper-plane"></i>
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="room-info">
          <div class="info-item">
            <i class="fas fa-share-alt"></i>
            <span>Пригласите друга: <code id="inviteCode"></code></span>
            <button id="copyInviteBtn" class="btn-small">
              <i class="fas fa-copy"></i> Копировать
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      class DrawingApp {
        constructor() {
          // ЗАМЕНИТЕ НА ВАШ РЕАЛЬНЫЙ URL RENDER БЭКЕНДА
          this.BACKEND_URL = "https://kitten-draw.onrender.com";
          this.socket = null;
          this.roomId = null;
          this.playerId = null;
          this.username = null;
          this.players = new Map();

          this.currentTool = "brush";
          this.currentColor = "#FF5252";
          this.brushSize = 5;
          this.isDrawing = false;
          this.lastX = 0;
          this.lastY = 0;
          this.startX = 0;
          this.startY = 0;

          this.canvas = document.getElementById("drawingCanvas");
          this.ctx = this.canvas.getContext("2d", { willReadFrequently: true });
          this.overlay = document.getElementById("canvasOverlay");
          this.overlayCtx = this.overlay.getContext("2d");

          this.history = [];
          this.historyIndex = -1;
          this.resizeTimeout = null;

          this.init();
        }

        async init() {
          this.setupEventListeners();
          this.initCanvas();
          await this.checkBackendStatus();
          this.connectSocket();
        }

        async checkBackendStatus() {
          try {
            // Используем mode: 'no-cors' для проверки доступности
            const response = await fetch(`${this.BACKEND_URL}/health`, {
              method: "GET",
              mode: "no-cors",
            });

            document.getElementById("backendStatus").textContent =
              "✅ Бэкенд доступен";
            document.getElementById("backendStatus").className =
              "backend-success";
          } catch (error) {
            console.log("Backend check failed, continuing anyway:", error);
            document.getElementById("backendStatus").textContent =
              "⚠️ Бэкенд может быть недоступен";
            document.getElementById("backendStatus").className =
              "backend-error";
          }
        }

        connectSocket() {
          console.log("Connecting to backend:", this.BACKEND_URL);

          // Socket.IO автоматически обрабатывает CORS
          this.socket = io(this.BACKEND_URL, {
            transports: ["websocket", "polling"],
            timeout: 10000,
          });

          this.socket.on("connect", () => {
            console.log("✅ Connected to backend");
            this.updateStatus("Подключено к серверу", "connected");
          });

          this.socket.on("disconnect", (reason) => {
            console.log("❌ Disconnected from backend:", reason);
            this.updateStatus("Отключено от сервера", "disconnected");
          });

          this.socket.on("connect_error", (error) => {
            console.error("Connection error:", error);
            this.updateStatus("Ошибка подключения", "disconnected");
            // Показываем сообщение для пользователя
            this.addSystemMessage(
              "Не удалось подключиться к серверу. Проверьте интернет соединение."
            );
          });

          this.socket.on("room_joined", (data) => {
            this.handleRoomJoined(data);
          });

          this.socket.on("player_joined", (data) => {
            this.handlePlayerJoined(data);
          });

          this.socket.on("player_left", (data) => {
            this.handlePlayerLeft(data);
          });

          this.socket.on("draw", (data) => {
            this.handleRemoteDraw(data);
          });

          this.socket.on("clear", (data) => {
            this.clearCanvas();
          });

          this.socket.on("chat_message", (data) => {
            this.displayChatMessage(data);
          });

          this.socket.on("error", (data) => {
            this.showError(data.message);
          });
        }

        setupEventListeners() {
          document
            .getElementById("createRoomBtn")
            .addEventListener("click", () => this.createRoom());
          document
            .getElementById("joinRoomBtn")
            .addEventListener("click", () => this.joinRoom());
          document
            .getElementById("leaveRoomBtn")
            .addEventListener("click", () => this.leaveRoom());

          document.querySelectorAll(".tool-btn").forEach((btn) => {
            btn.addEventListener("click", (e) =>
              this.selectTool(e.currentTarget.dataset.tool)
            );
          });

          document
            .getElementById("brushSizeSlider")
            .addEventListener("input", (e) => {
              this.brushSize = parseInt(e.target.value);
              document.getElementById("brushSizeValue").textContent =
                this.brushSize;
            });

          document.querySelectorAll(".color-option").forEach((option) => {
            option.addEventListener("click", (e) =>
              this.selectColor(e.target.dataset.color)
            );
          });

          document
            .getElementById("clearBtn")
            .addEventListener("click", () => this.requestClearCanvas());
          document
            .getElementById("saveBtn")
            .addEventListener("click", () => this.saveDrawing());
          document
            .getElementById("undoBtn")
            .addEventListener("click", () => this.undo());
          document
            .getElementById("copyInviteBtn")
            .addEventListener("click", () => this.copyInviteCode());

          document
            .getElementById("sendMessageBtn")
            .addEventListener("click", () => this.sendMessage());
          document
            .getElementById("chatInput")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter") this.sendMessage();
            });

          this.canvas.addEventListener("mousedown", (e) =>
            this.startDrawing(e)
          );
          this.canvas.addEventListener("mousemove", (e) => this.draw(e));
          this.canvas.addEventListener("mouseup", () => this.stopDrawing());
          this.canvas.addEventListener("mouseout", () => this.stopDrawing());
          this.canvas.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );

          // Дебаунс ресайза чтобы избежать рекурсии
          window.addEventListener("resize", () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => this.resizeCanvas(), 250);
          });
        }

        async createRoom() {
          const username =
            document.getElementById("usernameInput").value.trim() || "Аноним";
          this.username = username;

          try {
            // Пытаемся создать комнату через HTTP
            const response = await fetch(`${this.BACKEND_URL}/api/rooms`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ username }),
            });

            if (response.ok) {
              const data = await response.json();
              if (data.success) {
                this.joinRoom(data.roomId);
              } else {
                this.showError("Ошибка при создании комнаты");
              }
            } else {
              // Если HTTP запрос не удался, создаем комнату локально
              this.createRoomLocally();
            }
          } catch (error) {
            console.error("Error creating room:", error);
            // Создаем комнату локально если бэкенд недоступен
            this.createRoomLocally();
          }
        }

        createRoomLocally() {
          const username =
            document.getElementById("usernameInput").value.trim() || "Аноним";
          this.username = username;

          // Генерируем ID комнаты локально
          const roomId = Math.random()
            .toString(36)
            .substring(2, 8)
            .toUpperCase();
          this.joinRoom(roomId);

          this.addSystemMessage(
            "Бэкенд недоступен. Работаем в локальном режиме."
          );
        }

        async joinRoom(roomId = null) {
          const username =
            document.getElementById("usernameInput").value.trim() || "Аноним";
          const roomCode =
            roomId ||
            document.getElementById("roomCodeInput").value.trim().toUpperCase();

          if (!roomCode) {
            this.showError("Введите код комнаты");
            return;
          }

          this.username = username;
          this.roomId = roomCode;

          // Подключаемся к сокету если доступен
          if (this.socket && this.socket.connected) {
            this.doJoinRoom();
          } else {
            // Если сокет не доступен, переходим в локальный режим
            this.handleRoomJoined({
              roomId: this.roomId,
              playerId: 1,
              players: [{ id: 1, username: this.username, color: "#FF5252" }],
              canvasData: null,
            });
            this.addSystemMessage(
              "Режим оффлайн. Ожидаем подключения к серверу..."
            );
          }
        }

        doJoinRoom() {
          if (this.socket && this.socket.connected) {
            this.socket.emit("join_room", {
              roomId: this.roomId,
              username: this.username,
            });
          }
        }

        handleRoomJoined(data) {
          this.roomId = data.roomId;
          this.playerId = data.playerId;

          document.getElementById("loginScreen").classList.remove("active");
          document.getElementById("mainScreen").classList.add("active");

          document.getElementById("roomCodeDisplay").textContent = this.roomId;
          document.getElementById("inviteCode").textContent = this.roomId;

          this.players.clear();
          if (data.players) {
            data.players.forEach((player) => {
              this.players.set(player.id, player);
              this.updatePlayerDisplay(player.id, player);
            });
          }

          this.updatePlayersCount();

          if (data.canvasData) {
            const img = new Image();
            img.onload = () => {
              this.ctx.drawImage(img, 0, 0);
            };
            img.src = data.canvasData;
          }

          this.addSystemMessage(
            `Вы присоединились к комнате как ${this.username}`
          );
        }

        handlePlayerJoined(data) {
          this.players.set(data.player.id, data.player);
          this.updatePlayerDisplay(data.player.id, data.player);
          this.updatePlayersCount();
          this.addSystemMessage(
            `${data.player.username} присоединился к комнате`
          );
        }

        handlePlayerLeft(data) {
          this.players.delete(data.playerId);
          this.updatePlayerDisplay(data.playerId, null);
          this.updatePlayersCount();
          this.addSystemMessage("Игрок покинул комнату");
        }

        updatePlayerDisplay(playerId, player) {
          const elementId = `player${playerId}Name`;
          const element = document.getElementById(elementId);

          if (element) {
            if (player) {
              element.textContent = player.username;
              if (playerId === 1) {
                const badge =
                  element.parentElement.querySelector(".owner-badge");
                if (badge) badge.style.display = "inline";
              }
            } else {
              element.textContent = playerId === 1 ? "Игрок 1" : "Ожидание...";
              if (playerId === 1) {
                const badge =
                  element.parentElement.querySelector(".owner-badge");
                if (badge) badge.style.display = "none";
              }
            }
          }
        }

        updatePlayersCount() {
          const count = this.players.size;
          document.getElementById("playersCount").textContent = `${count}/2`;
        }

        selectTool(tool) {
          this.currentTool = tool;

          document.querySelectorAll(".tool-btn").forEach((btn) => {
            btn.classList.remove("active");
          });
          const activeBtn = document.querySelector(`[data-tool="${tool}"]`);
          if (activeBtn) activeBtn.classList.add("active");

          this.canvas.style.cursor =
            tool === "brush"
              ? "crosshair"
              : tool === "eraser"
              ? "cell"
              : "crosshair";
        }

        selectColor(color) {
          this.currentColor = color;

          document.querySelectorAll(".color-option").forEach((option) => {
            option.classList.remove("active");
          });
          const activeColor = document.querySelector(`[data-color="${color}"]`);
          if (activeColor) activeColor.classList.add("active");
        }

        startDrawing(e) {
          if (!this.roomId) return;

          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const scaleX = this.canvas.width / rect.width;
          const scaleY = this.canvas.height / rect.height;

          this.startX = this.lastX = (e.clientX - rect.left) * scaleX;
          this.startY = this.lastY = (e.clientY - rect.top) * scaleY;
          this.isDrawing = true;

          if (this.currentTool === "brush") {
            this.ctx.beginPath();
            this.ctx.moveTo(this.lastX, this.lastY);
          }

          this.saveToHistory();
        }

        draw(e) {
          if (!this.isDrawing || !this.roomId) return;

          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const scaleX = this.canvas.width / rect.width;
          const scaleY = this.canvas.height / rect.height;

          const currentX = (e.clientX - rect.left) * scaleX;
          const currentY = (e.clientY - rect.top) * scaleY;

          this.ctx.lineJoin = "round";
          this.ctx.lineCap = "round";

          switch (this.currentTool) {
            case "brush":
              this.drawBrush(currentX, currentY);
              break;
            case "eraser":
              this.drawEraser(currentX, currentY);
              break;
            case "line":
            case "rectangle":
            case "circle":
              this.drawShapePreview(currentX, currentY);
              break;
          }

          this.lastX = currentX;
          this.lastY = currentY;
        }

        drawBrush(x, y) {
          this.ctx.strokeStyle = this.currentColor;
          this.ctx.lineWidth = this.brushSize;

          this.ctx.lineTo(x, y);
          this.ctx.stroke();

          this.sendDrawData([
            [this.lastX, this.lastY],
            [x, y],
          ]);
        }

        drawEraser(x, y) {
          this.ctx.strokeStyle = "white";
          this.ctx.lineWidth = this.brushSize;

          this.ctx.lineTo(x, y);
          this.ctx.stroke();

          this.sendDrawData(
            [
              [this.lastX, this.lastY],
              [x, y],
            ],
            "white"
          );
        }

        drawShapePreview(x, y) {
          this.overlayCtx.clearRect(
            0,
            0,
            this.overlay.width,
            this.overlay.height
          );
          this.overlayCtx.strokeStyle = this.currentColor;
          this.overlayCtx.lineWidth = this.brushSize;
          this.overlayCtx.setLineDash([5, 5]);

          switch (this.currentTool) {
            case "line":
              this.overlayCtx.beginPath();
              this.overlayCtx.moveTo(this.startX, this.startY);
              this.overlayCtx.lineTo(x, y);
              this.overlayCtx.stroke();
              break;
            case "rectangle":
              const rectWidth = x - this.startX;
              const rectHeight = y - this.startY;
              this.overlayCtx.strokeRect(
                this.startX,
                this.startY,
                rectWidth,
                rectHeight
              );
              break;
            case "circle":
              const radius = Math.sqrt(
                Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2)
              );
              this.overlayCtx.beginPath();
              this.overlayCtx.arc(
                this.startX,
                this.startY,
                radius,
                0,
                Math.PI * 2
              );
              this.overlayCtx.stroke();
              break;
          }

          this.overlayCtx.setLineDash([]);
        }

        stopDrawing() {
          if (!this.isDrawing) return;

          this.isDrawing = false;
          this.ctx.beginPath();

          if (["line", "rectangle", "circle"].includes(this.currentTool)) {
            this.finalizeShape();
          }

          this.overlayCtx.clearRect(
            0,
            0,
            this.overlay.width,
            this.overlay.height
          );
        }

        finalizeShape() {
          const currentX = this.lastX;
          const currentY = this.lastY;

          this.ctx.strokeStyle = this.currentColor;
          this.ctx.lineWidth = this.brushSize;

          switch (this.currentTool) {
            case "line":
              this.ctx.beginPath();
              this.ctx.moveTo(this.startX, this.startY);
              this.ctx.lineTo(currentX, currentY);
              this.ctx.stroke();
              this.sendDrawData(
                [
                  [this.startX, this.startY],
                  [currentX, currentY],
                ],
                null,
                "line"
              );
              break;
            case "rectangle":
              const rectWidth = currentX - this.startX;
              const rectHeight = currentY - this.startY;
              this.ctx.strokeRect(
                this.startX,
                this.startY,
                rectWidth,
                rectHeight
              );
              this.sendDrawData(
                [
                  [this.startX, this.startY],
                  [currentX, currentY],
                ],
                null,
                "rectangle"
              );
              break;
            case "circle":
              const radius = Math.sqrt(
                Math.pow(currentX - this.startX, 2) +
                  Math.pow(currentY - this.startY, 2)
              );
              this.ctx.beginPath();
              this.ctx.arc(this.startX, this.startY, radius, 0, Math.PI * 2);
              this.ctx.stroke();
              this.sendDrawData(
                [
                  [this.startX, this.startY],
                  [currentX, currentY],
                ],
                null,
                "circle"
              );
              break;
          }
        }

        sendDrawData(points, color = null, tool = null) {
          if (!this.roomId || !this.socket?.connected) return;

          try {
            this.socket.emit("draw", {
              playerId: this.playerId,
              points: points,
              color: color || this.currentColor,
              brushSize: this.brushSize,
              tool: tool || this.currentTool,
              canvasData: this.canvas.toDataURL(),
            });
          } catch (error) {
            console.error("Error sending draw data:", error);
          }
        }

        handleRemoteDraw(data) {
          const points = data.points;
          const color = data.color;
          const brushSize = data.brushSize;
          const tool = data.tool;

          this.ctx.strokeStyle = color;
          this.ctx.lineWidth = brushSize;
          this.ctx.lineJoin = "round";
          this.ctx.lineCap = "round";

          if (tool === "brush" || tool === "eraser") {
            this.ctx.beginPath();
            this.ctx.moveTo(points[0][0], points[0][1]);
            this.ctx.lineTo(points[1][0], points[1][1]);
            this.ctx.stroke();
          } else if (tool === "line") {
            this.ctx.beginPath();
            this.ctx.moveTo(points[0][0], points[0][1]);
            this.ctx.lineTo(points[1][0], points[1][1]);
            this.ctx.stroke();
          } else if (tool === "rectangle") {
            const startX = points[0][0];
            const startY = points[0][1];
            const endX = points[1][0];
            const endY = points[1][1];
            this.ctx.strokeRect(startX, startY, endX - startX, endY - startY);
          } else if (tool === "circle") {
            const startX = points[0][0];
            const startY = points[0][1];
            const endX = points[1][0];
            const endY = points[1][1];
            const radius = Math.sqrt(
              Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
            );
            this.ctx.beginPath();
            this.ctx.arc(startX, startY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
          }
        }

        requestClearCanvas() {
          if (!this.roomId) return;

          if (confirm("Вы уверены, что хотите очистить холст?")) {
            this.clearCanvas();
            if (this.socket?.connected) {
              this.socket.emit("clear", {
                playerId: this.playerId,
              });
            }
          }
        }

        clearCanvas() {
          this.ctx.fillStyle = "white";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.history = [];
          this.historyIndex = -1;
          this.updateUndoButton();
        }

        saveDrawing() {
          const link = document.createElement("a");
          link.download = `рисунок-${this.roomId || "local"}-${new Date()
            .toISOString()
            .slice(0, 10)}.png`;
          link.href = this.canvas.toDataURL("image/png");
          link.click();
        }

        undo() {
          if (this.historyIndex > 0) {
            this.historyIndex--;
            const imageData = this.history[this.historyIndex];
            this.ctx.putImageData(imageData, 0, 0);
            this.updateUndoButton();
          }
        }

        saveToHistory() {
          if (this.history.length >= 20) {
            this.history.shift();
          }

          this.historyIndex = this.history.length;
          this.history.push(
            this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
          );
          this.updateUndoButton();
        }

        updateUndoButton() {
          const undoBtn = document.getElementById("undoBtn");
          if (undoBtn) {
            undoBtn.disabled = this.historyIndex <= 0;
          }
        }

        sendMessage() {
          const input = document.getElementById("chatInput");
          const message = input.value.trim();

          if (!message || !this.roomId) return;

          if (this.socket?.connected) {
            this.socket.emit("chat_message", {
              playerId: this.playerId,
              username: this.username,
              message: message,
            });
          } else {
            // Локальный чат если сервер недоступен
            this.displayChatMessage({
              playerId: this.playerId,
              username: this.username,
              message: message,
            });
          }

          input.value = "";
        }

        displayChatMessage(data) {
          const messagesContainer = document.getElementById("chatMessages");
          if (!messagesContainer) return;

          const messageDiv = document.createElement("div");

          messageDiv.className = `chat-message ${
            data.playerId === this.playerId ? "own" : ""
          }`;

          if (data.playerId === "system") {
            messageDiv.className = "chat-message system";
            messageDiv.innerHTML = `<div class="message-text">${data.message}</div>`;
          } else {
            messageDiv.innerHTML = `
                    <div class="message-sender">${data.username}</div>
                    <div class="message-text">${data.message}</div>
                `;
          }

          messagesContainer.appendChild(messageDiv);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        addSystemMessage(message) {
          this.displayChatMessage({
            playerId: "system",
            username: "Система",
            message: message,
          });
        }

        leaveRoom() {
          if (this.roomId) {
            if (this.socket) {
              this.socket.disconnect();
            }

            this.roomId = null;
            this.playerId = null;
            this.players.clear();

            document.getElementById("mainScreen").classList.remove("active");
            document.getElementById("loginScreen").classList.add("active");

            this.clearCanvas();
            this.connectSocket(); // Переподключаемся
          }
        }

        copyInviteCode() {
          if (this.roomId) {
            navigator.clipboard
              .writeText(this.roomId)
              .then(() => {
                this.addSystemMessage("Код комнаты скопирован в буфер обмена");
              })
              .catch(() => {
                // Fallback
                const tempInput = document.createElement("input");
                tempInput.value = this.roomId;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand("copy");
                document.body.removeChild(tempInput);
                this.addSystemMessage("Код комнаты скопирован в буфер обмена");
              });
          }
        }

        initCanvas() {
          this.ctx.fillStyle = "white";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          this.resizeCanvas();
        }

        resizeCanvas() {
          const container = this.canvas.parentElement;
          if (!container) return;

          const width = container.clientWidth;
          const height = Math.min(500, width * 0.625);

          // Проверяем, изменились ли размеры
          if (this.canvas.width === width && this.canvas.height === height) {
            return;
          }

          this.canvas.width = width;
          this.canvas.height = height;

          this.overlay.width = width;
          this.overlay.height = height;

          // Перерисовываем если есть данные
          const imageData = this.ctx.getImageData(0, 0, 1, 1).data;
          if (imageData[3] !== 0) {
            const tempCanvas = document.createElement("canvas");
            const tempCtx = tempCanvas.getContext("2d");
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.drawImage(this.canvas, 0, 0, width, height);
            this.initCanvas();
            this.ctx.drawImage(tempCanvas, 0, 0);
          }
        }

        updateStatus(text, className) {
          const statusElement = document.getElementById("status");
          if (statusElement) {
            statusElement.textContent = text;
            statusElement.className = className;
          }
        }

        showError(message) {
          alert(`Ошибка: ${message}`);
        }
      }

      // Инициализация приложения
      document.addEventListener("DOMContentLoaded", () => {
        new DrawingApp();
      });
    </script>
  </body>
</html>
